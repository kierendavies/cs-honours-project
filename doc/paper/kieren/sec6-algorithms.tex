% !TEX root = paper.tex
\documentclass[paper.tex]{subfiles}

\begin{document}

\section{Algorithms and analysis}
\label{sec:algorithms}

\begin{todos}
  % \todo Show correctness of anonymous individual approach, because reasoners use it (careful of difference)
  \todo Coverage (justification)
  \begin{todos}
    \todo Doesn't make sense to test declaration or data\-type definition
    \todo skip data property and annotation axioms because similiar to object property
    \todo HasKey?  Relates to same/different individuals
  \end{todos}
\end{todos}

We now present the algorithms and analysis, in the context of an ontology $O$.  As justified in section \ref{sec:model}, we assume the following preconditions:
\begin{itemize}[nosep]
  \item The ontology under test $O$ is consistent and coherent.
  \item The axiom under test contains only entities which are declared in the ontology.
\end{itemize}

Each algorithm is named according to the axiom it tests, as written in OWL 2 functional syntax, prepended with ``\textproc{test}''.  For example, the algorithm for testing $\mathtt{SubClassOf}$ axioms is named \textproc{testSubClassOf}.

We address class (TBox) axioms in section \ref{sec:algorithms:class}, assertion (ABox) axioms in section \ref{sec:algorithms:assert}, and object property (RBox) axioms in section \ref{sec:algorithms:objprop} \todo[TBC].  We do not address data property axioms or annotation axioms because their grammar and semantics are a equivalent to a fragment of object properties, and they are seldom involved in reasoning.

We also exclude $\mathtt{HasKey}$ because \todo[it's a horrible horrible mistake] \todo[cite].  We do not provide an algorithm to test it, and further, we assume that the ontology does not contain any $\mathtt{HasKey}$ axioms.

\subsection{Class axioms}
\label{sec:algorithms:class}

% \begin{itemize}[noitemsep]
%   \ttfamily
%   \item SubClassOf
%   \item EquivalentClasses
%   \item DisjointClasses
%   \item DisjointUnion
% \end{itemize}

In the class axioms permitted by OWL 2, all arguments may be arbitrary class expressions, not only named classes.  The only exception to this is $\mathtt{DisjointUnion}(C \; D_1 \; \ldots \; D_n)$ in which $C$ must be a named class.  Consequently, in implementing testing algorithms, \textproc{getSubClasses} is not generally useful because it returns only named classes.  To resolve this, we build larger class expressions from the arguments and query them for satisfiability and instances.

\begin{algorithm}[H]
  \caption{test $C \sqsubseteq D$}
  \begin{algorithmic}[1]
    \raggedright
    \Input{$C$, $D$ class expressions}
    \Function{testSubClassOf}{$C, D$}
      \If{$\Call{getInstances}{C \sqcap \neg D} \ne \emptyset$}
        \State \Return inconsistent
      \ElsIf{$\lnot \Call{isSatisfiable}{C \sqcap D} \land {}$ \\
          \algindent{3} $(\Call{getEquivalentClasses}{C} \union {}$ \\
          \algindent{3} $\phantom{(}\Call{getSubClasses}{C}) \ne \emptyset$}
        \State \Return incoherent
      \ElsIf{\Call{isSatisfiable}{$C \sqcap \neg D$}}
        \State \Return absent
      \Else
        \State \Return entailed
        \label{alg:testSubClassOf:returnEntailed}
      \EndIf
    \EndFunction
  \end{algorithmic}
\end{algorithm}

\begin{lemma}
  \textproc{testSubClassOf} is sound with respect to entailment.  That is,
  \begin{align*}
    & \textproc{testSubClassOf}(C, D) = \mathrm{entailed} \\
    \implies{}& \test_O(C \sqsubseteq D) = \mathrm{entailed}
  \end{align*}
\end{lemma}
\begin{proof}
  The algorithm can only return entailed at line \ref{alg:testSubClassOf:returnEntailed}, so the three if-conditions must all be false.  So
  \begin{multline}
    \label{eqn:testSubClassOfBranchesFalse}
    \textproc{getInstances}(C \sqcap \neg D) = \emptyset \land {} \\
    (\textproc{isSatisfiable}(C \sqcap D) \lor {} \\
    (\textproc{getEquivalentClasses}(C) \union {} \\
    \textproc{getSubClasses}(C)) = \emptyset) \land {} \\
    \lnot \textproc{isSatisfiable}(C \sqcap \neg D)
  \end{multline}

  %   Now suppose $O \nsementails C \sqsubseteq D$.  Since we have the precondition that $O$ is consistent and coherent, it is possible to introduce a new individual $a : C \sqcap \neg D$ \todo[is this valid?].  This means that $C \sqcap \neg D$ is satisfiable, which contradicts the last term of equation \ref{eqn:testSubClassOfBranchesFalse}.  Therefore the supposition is false, and $O \sementails C \sqsubseteq D$, and by its definition $\test_O(C \sqsubseteq D) = \mathrm{entailed}$.

  Now suppose $O \nsementails C \sqsubseteq D$.  That is, there exists an interpretation $\I$ such that
  \begin{align*}
    & \I \nsynentails C \sqsubseteq D \\
    \iff{}& C^\I \nsubseteq D^\I \\
    \iff{}& (\exists a \in C^\I) \; a \notin D^\I \\
    \iff{}& (\exists a \in \Delta^\I) \; a \in C^\I \land a \notin D^\I \\
    \iff{}& (\exists a \in \Delta^\I) \; a \in C^\I \intersect (\Delta^\I \setminus D^\I) \\
    \iff{}& (\exists a \in \Delta^\I) \; a \in C^\I \intersect (\neg D)^\I \\
    \iff{}& (\exists a \in \Delta^\I) \; a \in (C \sqcap \neg D)^\I \\
    \iff{}& (C \sqcap \neg D)^\I \ne \emptyset \\
    \iff{}& \I \nsynentails C \sqcap \neg D \sqsubseteq \bot
  \end{align*}
  Therefore $O \nsementails C \sqcap \neg D \sqsubseteq \bot$.  In other words, $C \sqcap \neg D$ is satisfiable, which contradicts the last term of equation \ref{eqn:testSubClassOfBranchesFalse}.  Hence the supposition is false, and $O \sementails C \sqsubseteq D$, and by its definition $\test_O(C \sqsubseteq D) = \mathrm{entailed}$.
\end{proof}

\begin{lemma}
  \textproc{testSubClassOf} is complete with respect to entailment.  That is,
  \begin{align*}
    & \test_O(C \sqsubseteq D) = \mathrm{entailed} \\
    \implies{}& \textproc{testSubClassOf}(C, D) = \mathrm{entailed}
  \end{align*}
\end{lemma}
\begin{proof}
  From the definition, $\test_O(C \sqsubseteq D) = \mathrm{entailed}$ means that $O \sementails C \sqsubseteq D$.  From this we have
  \[ C \sqcap \neg D \;\sqsubseteq\; D \sqcap \neg D \;\sqsubseteq\; \bot \]
  This means that $C \sqcap \neg D$ is not satisfiable, and from the consistency precondition it has no instances, so the first and last terms of equation \ref{eqn:testSubClassOfBranchesFalse} are true.

  If $C \sqcap D$ is satisfiable, then the middle term of equation \ref{eqn:testSubClassOfBranchesFalse} is true without needing to evaluate its second $\lor$-condition.  If not, we note that $C \sqsubseteq D$ implies $C \sqcap D \equiv C$.  By the coherence precondition, since $C$ is not satisfiable it has no named subclasses or equivalent classes, so the second $\lor$-condition is true.  Therefore the middle term is true in all cases.

  We have shown that all three terms of equation \ref{eqn:testSubClassOfBranchesFalse} are true, and so the algorithm returns entailed.
\end{proof}

% \begin{lemma}
%   \textproc{testSubClassOf} is sound with respect to incoherence.
% \end{lemma}
% \begin{proof}
%   \todo
% \end{proof}
%
% \begin{lemma}
%   \textproc{testSubClassOf} is complete with respect to incoherence.
% \end{lemma}
% \begin{proof}
%   \todo
% \end{proof}
%
% \begin{lemma}
%   \textproc{testSubClassOf} is sound with respect to inconsistency.
% \end{lemma}
% \begin{proof}
%   \todo
% \end{proof}
%
% \begin{lemma}
%   \textproc{testSubClassOf} is complete with respect to inconsistency.
% \end{lemma}
% \begin{proof}
%   \todo
% \end{proof}

\begin{theorem}
  \textproc{testSubClassOf} is correct and terminating.
\end{theorem}
\begin{proof}
  \todo[from lemmas]
  \todo[terminating, trivially]
\end{proof}

\begin{algorithm}[H]
  \caption{test $C_1 \equiv \ldots \equiv C_n$}
  \begin{algorithmic}[1]
    \raggedright
    \Input{$C_1$, \dots, $C_n$ class expressions}
    \Function{testEquivalentClasses}{$C_1, \,\ldots, C_n$}
      \State $r \gets$ entailed
      \For{$i \gets 2$ \To $n$}
        \State $r'_1 \gets \Call{testSubClassOf}{C_1, C_i}$
        \State $r'_2 \gets \Call{testSubClassOf}{C_i, C_1}$
        \State $r \gets \max(r, r'_1, r'_2)$
      \EndFor
      \State \Return $r$
    \EndFunction
  \end{algorithmic}
\end{algorithm}

\todo[don't need pairwise---assume worse result from $(i, j)$, show it appears in $(1, i)$ or $(1, j)$]

From OWL 2 spec,
\begin{align*}
  \mathtt{DisjointClasses}(C, D)
  &\iff C \sqsubseteq \neg D
  % &\iff C \sqcap D \sqsubseteq \bot
\end{align*}
But using $\textproc{testSubClassOf}(C_i, \neg C_j)$ fails to report incoherent when e.g.\ $D \equiv C_1 \sqcap C_2$ with no instances, so use stronger form $C \sqcap D \sqsubseteq \bot$ \todo[write properly].

\begin{algorithm}[H]
  \caption{test $C_1, \,\ldots, C_n$ pairwise disjoint}
  \begin{algorithmic}[1]
    \raggedright
    \Input{$C_1$, \dots, $C_n$ class expressions}
    \Function{testDisjointClasses}{$C_1$, \dots, $C_n$}
      \State $r \gets$ entailed
      \For{$i \gets 1$ \To $n-1$}
        \For{$j \gets i+1$ \To $n$}
          \If{$\Call{getInstances}{C_i \sqcap C_j} \ne \emptyset$}
            \State $r' \gets$ inconsistent
          \ElsIf{$(\Call{getEquivalentClasses}{C_i \sqcap C_j} \union {}$ \\
              \algindent{5} $\Call{getSubClasses}{C_i \sqcap C_j}) \ne \emptyset$}
            \State $r' \gets$ incoherent
          \ElsIf{\Call{isSatisfiable}{$C_i \sqcap C_j$}}
            \State $r' \gets$ absent
          \Else
            \State $r' \gets$ entailed
          \EndIf
          \State $r \gets \max(r, r')$
        \EndFor
      \EndFor
      \State \Return $r$
    \EndFunction
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
  \caption{test disjoint union $C \equiv D_1 \sqcup \ldots \sqcup D_n$ with $D_1, \,\ldots, D_n$ pairwise disjoint}
  \begin{algorithmic}[1]
    \raggedright
    \Input{
      $C$ class \\
      $D_1$, \dots, $D_n$ class expressions
    }
    \Function{testDisjointUnion}{$C$, $D_1$, \dots, $D_n$}
      \State $r_1 \gets \Call{testEquivalentClasses}{C, D_1 \sqcup \ldots \sqcup D_n}$
      \State $r_2 \gets \Call{testDisjointClasses}{D_1, \,\ldots, D_n}$
      \State \Return $\max(r_1, r_2)$
    \EndFunction
  \end{algorithmic}
\end{algorithm}

\todo[Presented without proof]

\subsection{Assertions}
\label{sec:algorithms:assert}

% \begin{itemize}[noitemsep]
%   \ttfamily
%   \item SameIndividual
%   \item DifferentIndividuals
%   \item ClassAssertion
%   \item ObjectPropertyAssertion
%   \item NegativeObjectPropertyAssertion
%   % \item DataPropertyAssertion
%   % \item NegativeDataPropertyAssertion
% \end{itemize}

\begin{algorithm}[H]
  \caption{test same individual}
  \begin{algorithmic}[1]
    \raggedright
    \Input{$a_1$, \dots, $a_n$ individuals}
    \Function{testSameIndividual}{$a_1$, \dots, $a_n$}
      \State \todo
    \EndFunction
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
  \caption{test different individuals}
  \begin{algorithmic}[1]
    \raggedright
    \Input{$a_1$, \dots, $a_n$ individuals}
    \Function{testDifferentIndividuals}{$a_1$, \dots, $a_n$}
      \State \todo
    \EndFunction
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
  \caption{test $a : C$}
  \begin{algorithmic}[1]
    \raggedright
    \Input{
      $C$ class expression \\
      $a$ individual
    }
    \Function{testClassAssertion}{$C$, $a$}
      \State \todo
    \EndFunction
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
  \caption{test $(a, b) : R$}
  \begin{algorithmic}[1]
    \raggedright
    \Input{
      $R$ object property expression \\
      $a$, $b$ individuals
    }
    \Function{testObjectPropertyAssertion}{$R$, $a$, $b$}
      \State \todo
    \EndFunction
  \end{algorithmic}
\end{algorithm}

\todo[name shortened to fit]
\begin{algorithm}[H]
  \caption{test $(a, b) : \neg R$}
  \begin{algorithmic}[1]
    \raggedright
    \Input{
      $R$ object property expression \\
      $a$, $b$ individuals
    }
    \Function{testNegObjectPropAssertion}{$R$, $a$, $b$}
      \State \todo
    \EndFunction
  \end{algorithmic}
\end{algorithm}

\subsection{Object property axioms}
\label{sec:algorithms:objprop}

\begin{itemize}[noitemsep]
  \ttfamily
  \item SubObjectPropertyOf
  \item EquivalentObjectProperties
  \item DisjointObjectProperties
  \item InverseObjectProperties
  \item ObjectPropertyDomain
  \item ObjectPropertyRange
  \item FunctionalObjectProperty
  \item InverseFunctionalObjectProperty
  \item ReflexiveObjectProperty
  \item IrreflexiveObjectProperty
  \item SymmetricObjectProperty
  \item AsymmetricObjectProperty
  \item TransitiveObjectProperty
\end{itemize}

% \begin{algorithm}[H]
%   \caption{test $R \sqsubseteq S$}
%   \begin{algorithmic}[1]
%     \Input{
%       $R$ object property expression or chain \\
%       $S$ object property
%     }
%     \Function{testSubObjectPropertyOf}{$R$, $S$}
%       \State \todo
%     \EndFunction
%   \end{algorithmic}
% \end{algorithm}
%
% \todo[other algorithm stubs]

% \subsection{Data property axioms}
%
% \begin{itemize}[noitemsep]
%   \ttfamily
%   \item SubDataPropertyOf
%   \item EquivalentDataProperties
%   \item DisjointDataProperties
%   \item DataPropertyDomain
%   \item DataPropertyRange
%   \item FunctionalDataProperty
% \end{itemize}
%
% \subsection{Annotation axioms}
%
% \begin{itemize}[noitemsep]
%   \ttfamily
%   \item AnnotationAssertion
%   \item SubAnnotationPropertyOf
%   \item AnnotationPropertyDomain
%   \item AnnotationPropertyRange
% \end{itemize}
%
% \subsection{Other}
%
% \begin{itemize}[noitemsep]
%   \ttfamily
%   \item HasKey
% \end{itemize}

\end{document}
