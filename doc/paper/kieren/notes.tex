\documentclass[11pt]{article}

\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{mathtools}
\newtheorem{proposition}{Proposition}
\newcommand{\union}{\cup}
\newcommand{\intersect}{\cap}
\newcommand{\sementails}{\mathrel{|}\joinrel\mkern-.5mu\mathrel{-}}
\newcommand{\synentails}{\mathrel{|}\joinrel\mathrel{=}}
\DeclareMathOperator{\signature}{signature}

\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage{hyphenat}
\let\oldtextproc\textproc
\renewcommand{\textproc}[1]{\nohyphens{\oldtextproc{#1}}}

\usepackage{enumitem}
\usepackage{soul}
\newenvironment{checklist}{%
  \begin{list}{}{}
  \providecommand{\todo}{\item[$\square$]}
  \providecommand{\done}{\item[$\text{\rlap{$\checkmark$}}\square$]}
}{%
  \end{list}
}

\begin{document}

\section{Objectives}

\begin{itemize}
  \item Extend Maria's tests with more descriptive outputs
  \item Cover complex axioms
  \item Which functionality supported by which reasoners?  Would like algorithms that work on all
\end{itemize}

\subsection{Coverage}

From OWL 2 grammar: (maybe not all of these)
\begin{checklist}
  \todo Declaration
  \todo ClassAxiom
  \begin{checklist}
    \todo SubClassOf
    \todo EquivalentClasses
    \todo DisjointClasses
    \todo \st{DisjointUnion}
  \end{checklist}
  \todo ObjectPropertyAxiom
  \todo DataPropertyAxiom
  \todo DatatypeDefinition
  \todo \st{HasKey}
  \todo Assertion
\end{checklist}

\section{Available functionality}

\begin{itemize}
  \item Check if ontology is inconsistent
  \item Add/remove arbitrary axioms
  \item Get sub/superclasses of class expression: \textproc{getSubClasses}, \textproc{getSuperClasses}
  \item Check if class expression is satisfiable: \textproc{isSatisfiable}
  \item \textproc{getInstances}, check if empty
\end{itemize}

Mock objects not acceptable.  Reclassification to be avoided.

\section{Definitions}

\begin{description}[noitemsep]
  \item[inconsistent] The ontology is inconsistent independent of the test
  \item[missing entity] One or more of the entity literals in the axiom has not been declared in the ontology
  \item[valid] The axiom is already entailed
  \item[satisfiable] The axiom is not entailed, but neither is its converse, so it can be safely added
  \item[unsatisfiable] The converse of the axiom is entailed, so it cannot be added without creating a contradiction or an unsatisfiable class
\end{description}

\[
  \mathrm{test}_O(A) =
  \begin{cases}
    \mathrm{inconsistent} &
      \mbox{if } O \sementails \bot \\
    \mathrm{missing\,entity} &
      \mbox{if } \signature(A) \not\subseteq \signature(O) \\
    \mathrm{valid} &
      \mbox{if } O \sementails A \\
    \mathrm{unsatisfiable} &
      \mbox{if } O \union A \sementails \bot \\
    \mathrm{satisfiable} &
      \mbox{otherwise}
  \end{cases}
\]
(be clearer about cases?)

\section{Algorithms}

\begin{description}[noitemsep]
  \item[Soundness] we say it's true $\implies$ it is true \\ ($\Gamma \synentails \phi \implies \Gamma \sementails \phi$)
  \item[Completeness] it is true $\implies$ we say it's true \\ ($\Gamma \sementails \phi \implies \Gamma \synentails \phi$)
\end{description}

\subsection{Using entailment checking}

Directly see if any axiom is valid, but also want to see satisfiable and unsatisfiable.

\begin{algorithm}[H]
  \caption{Test concept inclusion using entailment checking}
  \begin{algorithmic}[1]
    \Function{testSubClassOf}{$C$, $D$}
      \If{\Call{isEntailed}{$C \sqsubseteq D$}}
        \State \Return valid
      \ElsIf{\Call{isEntailed}{}}

      \EndIf
    \EndFunction
  \end{algorithmic}
\end{algorithm}

\subsection{Using satisfiability checking}

\begin{algorithm}[H]
  \caption{Test concept inclusion using satisfiability checking}
  \begin{algorithmic}[1]
    \Function{testSubClassOf}{$C$, $D$}
      \If{$C \sqcap \neg D$ has instances}
        \Comment or enumerate $C$ and check in $D$
        \State \Return unsatisfiable
      \ElsIf{$C \sqcap \neg D$ is satisfiable}
        \State \Return satisfiable
      \Else
        \State \Return valid
      \EndIf
    \EndFunction
  \end{algorithmic}
\end{algorithm}

\end{document}
