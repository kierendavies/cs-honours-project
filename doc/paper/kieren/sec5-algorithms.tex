% !TEX root = paper.tex
\documentclass[paper.tex]{subfiles}

\begin{document}

\section{Unit testing algorithms}
\label{sec:algorithms}

\begin{todos}
  \todo Name according to OWL functional syntax
  \todo Show correctness of anonymous individual approach, because reasoners use it (careful of difference)
  \todo Coverage (justification)
\end{todos}

\subsection{Class axioms}

\begin{algorithm}[H]
  \caption{test $C \sqsubseteq D$}
  \begin{algorithmic}[1]
    \raggedright
    \Function{testSubClassOf}{$C, D$}
      \If{$\Call{getInstances}{C \sqcap \neg D} \ne \emptyset$}
        \State \Return inconsistent
      \ElsIf{$\lnot \Call{isSatisfiable}{C \sqcap D} \land {}$ \\
        \algindent{3} $(\Call{isClassExpressionLiteral}{C} \lor {}$ \\
        \algindent{3} $\phantom{(}\Call{getSubClasses}{C} \ne \emptyset)$}
        \State \Return incoherent
      \ElsIf{\Call{isSatisfiable}{$C \sqcap \neg D$}}
        \State \Return absent
      \Else
        \State \Return entailed
      \EndIf
    \EndFunction
  \end{algorithmic}
\end{algorithm}

% \begin{lemma}
%   \textproc{testSubClassOf} is sound with respect to entailment.  That is,
%   \begin{align*}
%     & \textproc{testSubClassOf}(C, D) = \mathrm{entailed} \\
%     \implies{}& \test_O(C \sqsubseteq D) = \mathrm{entailed}
%   \end{align*}
% \end{lemma}
% \begin{proof}
%   \todo
% \end{proof}
%
% \begin{lemma}
%   \textproc{testSubClassOf} is complete with respect to entailment.  That is,
%   \begin{align*}
%     & \test_O(C \sqsubseteq D) = \mathrm{entailed} \\
%     \implies{}& \textproc{testSubClassOf}(C, D) = \mathrm{entailed}
%   \end{align*}
% \end{lemma}
% \begin{proof}
%   \todo
% \end{proof}
%
% \begin{lemma}
%   \textproc{testSubClassOf} is sound with respect to incoherence.
% \end{lemma}
% \begin{proof}
%   \todo
% \end{proof}
%
% \begin{lemma}
%   \textproc{testSubClassOf} is complete with respect to incoherence.
% \end{lemma}
% \begin{proof}
%   \todo
% \end{proof}
%
% \begin{lemma}
%   \textproc{testSubClassOf} is sound with respect to inconsistency.
% \end{lemma}
% \begin{proof}
%   \todo
% \end{proof}
%
% \begin{lemma}
%   \textproc{testSubClassOf} is complete with respect to inconsistency.
% \end{lemma}
% \begin{proof}
%   \todo
% \end{proof}
%
% \begin{theorem}
%   \textproc{testSubClassOf} is correct and terminating.
% \end{theorem}
% \begin{proof}
%   \todo[terminating, trivially]
%   \todo[absent is default]
% \end{proof}

\begin{algorithm}[H]
  \caption{test $C_1 \equiv \ldots \equiv C_n$}
  \begin{algorithmic}[1]
    \Function{testEquivalentClasses}{$C_1, \,\ldots, C_n$}
      \State $r \gets$ entailed
      \For{$i \gets 2$ \To $n$}
        \State $r'_1 \gets \Call{testSubClassOf}{C_1, C_i}$
        \State $r'_2 \gets \Call{testSubClassOf}{C_i, C_1}$
        \State $r \gets \max(r, r'_1, r'_2)$
      \EndFor
      \State \Return $r$
    \EndFunction
  \end{algorithmic}
\end{algorithm}

\todo[don't need pairwise---assume worse result from $(i, j)$, show it appears in $(1, i)$ or $(1, j)$]

\begin{align*}
  \mathtt{DisjointClasses}(C, D)
  &\iff C \sqsubseteq \neg D \\
  &\iff C \sqcap D \sqsubseteq \bot
\end{align*}

\begin{algorithm}[H]
  \caption{test $C_1, \,\ldots, C_n$ pairwise disjoint}
  \begin{algorithmic}[1]
    \Function{testDisjointClasses}{$C_1, \,\ldots, C_n$}
      \State $r \gets$ entailed
      \For{$i \gets 1$ \To $n-1$}
        \For{$j \gets i+1$ \To $n$}
          \State $r' \gets \Call{testSubClassOf}{C_i, \neg C_j}$
          \State $r \gets \max(r, r')$
        \EndFor
      \EndFor
      \State \Return $r$
    \EndFunction
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
  \caption{test $C_1, \,\ldots, C_n$ pairwise disjoint}
  \begin{algorithmic}[1]
    \Function{testDisjointClasses}{$C_1$, \dots, $C_n$}
      \State $r \gets$ entailed
      \For{$i \gets 1$ \To $n-1$}
        \For{$j \gets i+1$ \To $n$}
          \If{$\Call{getInstances}{C_i \sqcap C_j} \ne \emptyset$}
            \State $r' \gets$ inconsistent
          \ElsIf{\todo}
            \State $r' \gets$ incoherent
          \ElsIf{\Call{isSatisfiable}{$C_i \sqcap C_j$}}
            \State $r' \gets$ entailed
          \Else
            \State $r' \gets$ absent
          \EndIf
          \State $r \gets \max(r, r')$
        \EndFor
      \EndFor
      \State \Return $r$
    \EndFunction
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
  \caption{test $C \equiv D_1 \sqcup \ldots \sqcup D_n$ and $D_1, \,\ldots, D_n$ pairwise disjoint}
  \begin{algorithmic}[1]
    \Function{testDisjointUnion}{$C$, $D_1$, \dots, $D_n$}
    \EndFunction
  \end{algorithmic}
\end{algorithm}

\subsection{Object property axioms}
\subsection{Data property axioms}
\subsection{Assertion axioms}

\end{document}
