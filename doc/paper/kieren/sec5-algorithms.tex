% !TEX root = paper.tex
\documentclass[paper.tex]{subfiles}

\begin{document}

\section{Unit testing algorithms}
\label{sec:algorithms}

\begin{todos}
  \todo Name according to OWL functional syntax
  % \todo Show correctness of anonymous individual approach, because reasoners use it (careful of difference)
  \todo Coverage (justification)
  \begin{todos}
    \todo Doesn't make sense to test declaration or data\-type definition
    \todo skip data property and annotation axioms because similiar to object property
    \todo HasKey?  Relates to same/different individuals
  \end{todos}
\end{todos}

\subsection{Class axioms (TBox)}

\begin{todos}
  \todo \textproc{getSubClasses} and \textproc{getSuperClasses} get only named classes, want arbitrary class expressions
\end{todos}

\begin{itemize}[noitemsep]
  \ttfamily
  \item SubClassOf
  \item EquivalentClasses
  \item DisjointClasses
  \item DisjointUnion
\end{itemize}

\begin{algorithm}[H]
  \caption{test $C \sqsubseteq D$}
  \begin{algorithmic}[1]
    \raggedright
    \Input{$C$, $D$ class expressions}
    \Function{testSubClassOf}{$C, D$}
      \If{$\Call{getInstances}{C \sqcap \neg D} \ne \emptyset$}
        \State \Return inconsistent
      \ElsIf{$\lnot \Call{isSatisfiable}{C \sqcap D} \land {}$ \\
          \algindent{3} $(\Call{getEquivalentClasses}{C} \union {}$ \\
          \algindent{3} $\phantom{(}\Call{getSubClasses}{C}) \ne \emptyset$}
        \State \Return incoherent
      \ElsIf{\Call{isSatisfiable}{$C \sqcap \neg D$}}
        \State \Return absent
      \Else
        \State \Return entailed
      \EndIf
    \EndFunction
  \end{algorithmic}
\end{algorithm}

% \begin{lemma}
%   \textproc{testSubClassOf} is sound with respect to entailment.  That is,
%   \begin{align*}
%     & \textproc{testSubClassOf}(C, D) = \mathrm{entailed} \\
%     \implies{}& \test_O(C \sqsubseteq D) = \mathrm{entailed}
%   \end{align*}
% \end{lemma}
% \begin{proof}
%   \todo
% \end{proof}
%
% \begin{lemma}
%   \textproc{testSubClassOf} is complete with respect to entailment.  That is,
%   \begin{align*}
%     & \test_O(C \sqsubseteq D) = \mathrm{entailed} \\
%     \implies{}& \textproc{testSubClassOf}(C, D) = \mathrm{entailed}
%   \end{align*}
% \end{lemma}
% \begin{proof}
%   \todo
% \end{proof}
%
% \begin{lemma}
%   \textproc{testSubClassOf} is sound with respect to incoherence.
% \end{lemma}
% \begin{proof}
%   \todo
% \end{proof}
%
% \begin{lemma}
%   \textproc{testSubClassOf} is complete with respect to incoherence.
% \end{lemma}
% \begin{proof}
%   \todo
% \end{proof}
%
% \begin{lemma}
%   \textproc{testSubClassOf} is sound with respect to inconsistency.
% \end{lemma}
% \begin{proof}
%   \todo
% \end{proof}
%
% \begin{lemma}
%   \textproc{testSubClassOf} is complete with respect to inconsistency.
% \end{lemma}
% \begin{proof}
%   \todo
% \end{proof}
%
% \begin{theorem}
%   \textproc{testSubClassOf} is correct and terminating.
% \end{theorem}
% \begin{proof}
%   \todo[terminating, trivially]
%   \todo[absent is default]
% \end{proof}

\begin{algorithm}[H]
  \caption{test $C_1 \equiv \ldots \equiv C_n$}
  \begin{algorithmic}[1]
    \raggedright
    \Input{$C_1$, \dots, $C_n$ class expressions}
    \Function{testEquivalentClasses}{$C_1, \,\ldots, C_n$}
      \State $r \gets$ entailed
      \For{$i \gets 2$ \To $n$}
        \State $r'_1 \gets \Call{testSubClassOf}{C_1, C_i}$
        \State $r'_2 \gets \Call{testSubClassOf}{C_i, C_1}$
        \State $r \gets \max(r, r'_1, r'_2)$
      \EndFor
      \State \Return $r$
    \EndFunction
  \end{algorithmic}
\end{algorithm}

\todo[don't need pairwise---assume worse result from $(i, j)$, show it appears in $(1, i)$ or $(1, j)$]

\begin{align*}
  \mathtt{DisjointClasses}(C, D)
  &\iff C \sqsubseteq \neg D \\
  &\iff C \sqcap D \sqsubseteq \bot
\end{align*}

\todo[Using $\textproc{testSubClassOf}(C_i, \neg C_j)$ fails to report incoherent when e.g. $D \equiv C_1 \sqcap C_2$ with no instances]

\begin{algorithm}[H]
  \caption{test $C_1, \,\ldots, C_n$ pairwise disjoint}
  \begin{algorithmic}[1]
    \raggedright
    \Input{$C_1$, \dots, $C_n$ class expressions}
    \Function{testDisjointClasses}{$C_1$, \dots, $C_n$}
      \State $r \gets$ entailed
      \For{$i \gets 1$ \To $n-1$}
        \For{$j \gets i+1$ \To $n$}
          \If{$\Call{getInstances}{C_i \sqcap C_j} \ne \emptyset$}
            \State $r' \gets$ inconsistent
          \ElsIf{$(\Call{getEquivalentClasses}{C_i \sqcap C_j} \union {}$ \\
              \algindent{5} $\Call{getSubClasses}{C_i \sqcap C_j}) \ne \emptyset$}
            \State $r' \gets$ incoherent
          \ElsIf{\Call{isSatisfiable}{$C_i \sqcap C_j$}}
            \State $r' \gets$ absent
          \Else
            \State $r' \gets$ entailed
          \EndIf
          \State $r \gets \max(r, r')$
        \EndFor
      \EndFor
      \State \Return $r$
    \EndFunction
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
  \caption{test disjoint union $C \equiv D_1 \sqcup \ldots \sqcup D_n$ with $D_1, \,\ldots, D_n$ pairwise disjoint}
  \begin{algorithmic}[1]
    \raggedright
    \Input{
      $C$ class \\
      $D_1$, \dots, $D_n$ class expressions
    }
    \Function{testDisjointUnion}{$C$, $D_1$, \dots, $D_n$}
      \State $r_1 \gets \Call{testEquivalentClasses}{C, D_1 \sqcup \ldots \sqcup D_n}$
      \State $r_2 \gets \Call{testDisjointClasses}{D_1, \,\ldots, D_n}$
      \State \Return $\max(r_1, r_2)$
    \EndFunction
  \end{algorithmic}
\end{algorithm}

\todo[Presented without proof]

\subsection{Assertions (ABox)}

\begin{itemize}[noitemsep]
  \ttfamily
  \item SameIndividual
  \item DifferentIndividuals
  \item ClassAssertion
  \item ObjectPropertyAssertion
  \item NegativeObjectPropertyAssertion
  % \item DataPropertyAssertion
  % \item NegativeDataPropertyAssertion
\end{itemize}

\begin{algorithm}[H]
  \caption{test same individual}
  \begin{algorithmic}[1]
    \raggedright
    \Input{$a_1$, \dots, $a_n$ individuals}
    \Function{testSameIndividual}{$a_1$, \dots, $a_n$}
      \State \todo
    \EndFunction
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
  \caption{test different individuals}
  \begin{algorithmic}[1]
    \raggedright
    \Input{$a_1$, \dots, $a_n$ individuals}
    \Function{testDifferentIndividuals}{$a_1$, \dots, $a_n$}
      \State \todo
    \EndFunction
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
  \caption{test $a : C$}
  \begin{algorithmic}[1]
    \raggedright
    \Input{
      $C$ class expression \\
      $a$ individual
    }
    \Function{testClassAssertion}{$C$, $a$}
      \State \todo
    \EndFunction
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
  \caption{test $(a, b) : R$}
  \begin{algorithmic}[1]
    \raggedright
    \Input{
      $R$ object property expression \\
      $a$, $b$ individuals
    }
    \Function{testObjectPropertyAssertion}{$R$, $a$, $b$}
      \State \todo
    \EndFunction
  \end{algorithmic}
\end{algorithm}

\begin{algorithm}[H]
  \caption{test $(a, b) : \neg R$}
  \begin{algorithmic}[1]
    \raggedright
    \Input{
      $R$ object property expression \\
      $a$, $b$ individuals
    }
    \Function{testNegObjectPropAssertion}{$R$, $a$, $b$}
      \State \todo
    \EndFunction
  \end{algorithmic}
\end{algorithm}

\subsection{Object property axioms (RBox)}

\begin{itemize}[noitemsep]
  \ttfamily
  \item SubObjectPropertyOf
  \item EquivalentObjectProperties
  \item DisjointObjectProperties
  \item InverseObjectProperties
  \item ObjectPropertyDomain
  \item ObjectPropertyRange
  \item FunctionalObjectProperty
  \item InverseFunctionalObjectProperty
  \item ReflexiveObjectProperty
  \item IrreflexiveObjectProperty
  \item SymmetricObjectProperty
  \item AsymmetricObjectProperty
  \item TransitiveObjectProperty
\end{itemize}

\begin{algorithm}[H]
  \caption{test $R \sqsubseteq S$}
  \begin{algorithmic}[1]
    \Input{
      $R$ object property expression or chain \\
      $S$ object property
    }
    \Function{testSubObjectPropertyOf}{$R$, $S$}
      \State \todo
    \EndFunction
  \end{algorithmic}
\end{algorithm}

\todo[other algorithm stubs]

% \subsection{Data property axioms}
%
% \begin{itemize}[noitemsep]
%   \ttfamily
%   \item SubDataPropertyOf
%   \item EquivalentDataProperties
%   \item DisjointDataProperties
%   \item DataPropertyDomain
%   \item DataPropertyRange
%   \item FunctionalDataProperty
% \end{itemize}
%
% \subsection{Annotation axioms}
%
% \begin{itemize}[noitemsep]
%   \ttfamily
%   \item AnnotationAssertion
%   \item SubAnnotationPropertyOf
%   \item AnnotationPropertyDomain
%   \item AnnotationPropertyRange
% \end{itemize}
%
% \subsection{Other}
%
% \begin{itemize}[noitemsep]
%   \ttfamily
%   \item HasKey
% \end{itemize}

\end{document}
